proc DrawCircle buffer, centerX, centerY, radius, color

    mov ecx, dword [radius]
    mov eax, 0
    mov edx, ecx

    mov edi, dword [centerY]

    mov esi, dword [buffer]
    
    mov ebx,0
    imul ebx, edi, Width
    add ebx, ecx
    add ebx, dword [centerX]
    shl ebx,2
    add esi, ebx ; Calculate the starting address of the circle

    circleLoop:
        ; Draw pixels at the eight octants of the circle
        ; Use symmetry to reduce calculations
        push eax
        mov eax, dword[color]
        mov [esi], eax

        mov ebx, dword[centerX]
        sub ebx, edi
        push ebx
        shl ebx,2
        add esi, ebx
        pop ebx
        mov [esi], eax

        mov ebx, dword[centerY]
        sub ebx, edi
        push ebx
        push eax
        mov eax,ebx
        mov ebx,0
        imul ebx, eax, Width
        shl ebx,2
        add esi, ebx
        pop eax
        pop ebx
        mov [esi], eax

        mov ebx, dword[centerY]
        sub ebx, dword[centerX]
        push ebx
        shl ebx,2
        sub esi, ebx
        pop ebx
        mov [esi], eax

        mov ebx, dword[centerX]
        add ebx, edi
        push ebx
        shl ebx,2
        sub esi, ebx
        pop ebx
        mov [esi], eax

        
        imul ebx, edi, Width
        shl ebx,2
        sub esi, ebx
        mov ebx, edi
        mov [esi],eax

        mov ebx, dword[centerY]
        add ebx, edi
        push ebx
        push eax
        mov eax,ebx
        mov ebx,0
        imul ebx, eax, Width
        shl ebx,2
        sub esi, ebx
        pop eax
        pop ebx
        mov [esi], eax

        mov ebx, dword[centerY]
        add ebx, dword[centerX]
        push ebx
        shl ebx,2
        add esi, ebx
        pop ebx
        mov [esi], eax
        pop eax

        ; Move on the circle using the midpoint algorithm
        push edi
        shl edi,1
        inc edi
        add eax, edi
        pop edi
        cmp eax, 0
        jl  noAdd
        push ebx
        shl ebx,1
        dec ebx
        sub eax, ebx
        pop ebx
        sub edx, 2
        dec ebx
    noAdd:

        inc edi
        cmp edx, 0
        jl  noSub
        push ecx
        shl ecx,1
        dec ecx
        sub edx, ecx
        pop ecx
        sub eax, 2
        dec ecx
    noSub:

        ; Check if the entire circle is drawn
        cmp ecx, 0
        jg  circleLoop

    ret
endp











void plot_circle(int x, int y, int x_center, int  y_center, int color_code)
{
    mempoint(x_center+x,y_center+y,color_code);
    mempoint(x_center+x,y_center-y,color_code);
    mempoint(x_center-x,y_center+y,color_code);
    mempoint(x_center-x,y_center-y,color_code);
}

/* Вычерчивание окружности с использованием алгоритма Мичнера */
void circle(int x_center, int y_center, int radius, int color_code)
{
    int x,y,delta;
    x = 0;
    y = radius;
    delta=3-2*radius;
    while(x<y) {
        plot_circle(x,y,x_center,y_center,color_code);
        plot_circle(y,x,x_center,y_center,color_code);
        if (delta<0)
            delta+=4*x+6;
        else {
            delta+=4*(x-y)+10;
            y--;
        }
        x++;
    }

    if(x==y) plot_circle(x,y,x_center,y_center,color_code);
}





// R - радиус, X1, Y1 - координаты центра
   int x := 0
   int y := R
   int delta := 1 - 2 * R
   int error := 0
   while (y >= 0)
       drawpixel(X1 + x, Y1 + y)
       drawpixel(X1 + x, Y1 - y)
       drawpixel(X1 - x, Y1 + y)
       drawpixel(X1 - x, Y1 - y)
       error = 2 * (delta + y) - 1
       if ((delta < 0) && (error <= 0))
           delta += 2 * ++x + 1
           continue
       error = 2 * (delta - x) - 1
       if ((delta > 0) && (error > 0))
           delta += 1 - 2 * --y
           continue
       x++
       delta += 2 * (x - y)
       y--